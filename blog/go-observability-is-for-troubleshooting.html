<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-language" content="en">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>Observability is for troubleshooting</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The difference between monitoring and observability is the fact that observability is for troubleshooting. And you troubleshoot in any environment not only in production. This article contains how I do observability in one of my application in Go.">
    <meta name="keywords" content="go, golang, zap, tracing, opentracing, observability, log">
    <meta name="google-site-verification" content="FoOIQ005srOjHlH19pNWapHvlOOVgCqHsz47IfQ6QNo" />
    <link rel="canonical" href="https://gianarb.it/blog/go-observability-is-for-troubleshooting">
    <link rel="icon" type="image/png" href="/img/favicon.png" />

    <link rel='alternate' type='application/atom+xml' title='Atom 0.3' href='/atom.xml'>

    <link rel="stylesheet" href="/assets/css/main.css">

</head>

    <body>
      <script>
            function advchecker() {
               document.getElementById('adv-sponsor').style.display = "block";
            }
      </script>
      <!--<div class="carbon-banner">-->
      <!--<script async style="display:none;" onerror="advchecker()" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7DLK7L&placement=gianarbit" id="_carbonads_js"></script>-->
<!--</div>-->

<h1>Observability is for troubleshooting</h1>
<main>
    <p class="meta">28 Feb 2019 · <!-- thanks to https://www.davidputney.com/2016/07/how-medium-style-read-time-estimate.html -->


<span class="blog-read-time">Two minute read</span>
 · on <a href="/blog">Gianluca's blog</a></p>

<p style="display:none;" class="note" id="adv-sponsor">Hey! I see you use an adblocker as I do as
well! I use Carbon Adv to support this tiny website a network with developers
in mind. Please consider disabling the adblocker for this website to support my
work.</p>

    <article>
    <p>Monitoring notifies you when something does not work. You get an alert, a slap in
the face based on the priority of the issue.  Observability is about
troubleshooting, debugging, “looking around.” You don’t use observability
techniques only when something doesn’t work.</p>

<p>Mainly because you don’t know where it happens, it can be anytime.
You observe during development, locally or in production, anytime.</p>

<p>The ability to use the same observability tools and techniques such as tracing,
log analysis and metrics is a tremendous value. You get used to them day by day
and not only under pressure, during an outage.
I practical trip that I can give you when you are instrumenting an application
is about interconnection. You need a way to connect logs, with traces and with
metrics.</p>

<p>There is nothing too complicated to understand. Every HTTP request has its own
generated ID.</p>

<p>This ID will become the trace ID, and it will be attached to all the logs
generated by that request.
One of my application I instrumented uses
<a href="https://github.com/opentracing/opentracing-go">opentracing/opentracing-to</a> and
<a href="https://github.com/uber-go/zap">uber-go/zap</a> as the logger.  I use a middleware
similar to the one provided by the
<a href="https://github.com/opentracing-contrib/go-stdlib/blob/master/nethttp/server.go">opentracing-contrib/go-stdlib</a>.</p>

<p>Inside an HTTP handler, I configure the logger to add the <code>trace_id</code> for every
log:</p>

<pre><code class="language-go">logger := GetLogger().With(zap.String("api.handler", "ping"))
if intTraceId := req.Context().Value("internal_trace_id"); intTraceId != nil {
    logger = logger.With(zap.String("trace_id", intTraceId.(string)))
}
</code></pre>
<p>In this way from this point in time the <code>logger</code> will add the trace_id to every line of log.</p>

<p>With this code <code>req.Context().Value("internal_trace_id")</code> I am retrieving the
“trace_id” from the context. In Go every HTTP request has a context attached and
this work because inside the middleware I set the trace_id in the context of the
request and also as HTTP header:</p>

<pre><code class="language-go">// This is a temporary fix until this issue will be addressed
// https://github.com/opentracing/opentracing-go/issues/188
// This works only with Zipkin.
zipkinSpan, ok := sp.Context().(zipkin.SpanContext)
if ok == true &amp;&amp; zipkinSpan.TraceID.Empty() == false {
  w.Header().Add("X-Trace-ID", zipkinSpan.TraceID.ToHex())
  r = r.WithContext(context.WithValue(r.Context(), "internal_trace_id", zipkinSpan.TraceID.ToHex()))
}
</code></pre>
<p>Having the <code>trace_id</code> exposed as header is nice because I can ask and traing
everyone to just grab that parameter when they have issues. Or we can code the
API consumer in a way that takes care about this value when something doesn’t go
as expected.</p>

<p>All these connections are useful to build a context from different sources. This
is the secret for happiness and Welcome to my Wonderland!</p>

<p><img src="/img/alice-observability.jpg" alt="" /></p>

    </article>
</main>


      <small class="footer">Something weird with this website? <a href="https://github.com/gianarb/gianarb.github.com/issues/new" target="_blank">Let me know</a>.</small>

    </body>
</html>

